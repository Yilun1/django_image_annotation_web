<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>canvas annotation</title>
    {%load static%}
    <script src="{%static 'js/jquery.js'%}"></script>
    <style>
    canvas
    {
      touch-action: pinch-zoom;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -moz-user-select: none;
    }
    button
    {
      background-color: white;
      color: black;
      padding: 10px 20px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 12px;
      -webkit-transition-duration: 0.4s; /* Safari */
      transition-duration: 0.4s;
      border-radius: 10px;
      border: 3px solid green;
      box-shadow: 0 12px 16px 0 rgba(0,0,0,0.24), 0 17px 50px 0 rgba(0,0,0,0.19);
    }
    button:hover
    {
       background-color: green;
    }

    button2
    {
      background-color: white;
      color: black;
      margin-left: 10px;
      margin-top: 10px;
      padding: 10px 20px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      cursor: pointer;
      font-size: 12px;
        -webkit-transition-duration: 0.4s; /* Safari */
        transition-duration: 0.4s;
        border-radius: 10px;
        border: 3px solid #5897fb;
    }
    button2:hover
    {
      background-color: #5897fb;
      box-shadow: 0 12px 16px 0 rgba(0,0,0,0.24), 0 17px 50px 0 rgba(0,0,0,0.19);
    }

    button3
    {
      background-color: white;
      color: black;
      margin-left: 5px;
      padding: 5px 5px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 15px;
      border-radius: 1px;
      border: 1px solid white;
    }

    .btn-group button
    {
      text-align: center;
      margin-top: 10px;
      background-color: white;
      border: 1px solid #5897fb;
      color: black;
      font-size: 15px;
      padding: 5px 5px;
      cursor: pointer;
      float: left;
    }
    .btn-group:after
    {
      content: "";
      clear: both;
      display: table;
    }
    .btn-group button:not(:last-child)
    {
      border-right: none;
    }
    .btn-group button:hover
    {
      background-color: #5897fb;
    }
    input
    {
      margin-left: 10px;
      border-radius: 10px;
      border: 3px solid #5897fb;
    }
    </style>
    <link rel="icon" href="{% static 'favicon.ico' %}">
	</head>

	<body>
  <button3 id="show_imagename"></button3>
  <canvas id="myCanvas"></canvas>
  <form>
    {%csrf_token%}
  </form>

<script >// all the scripts of the annotation tool

// ! Most of the possible warnings appear because var used instead of let or const
var canvas=document.getElementById('myCanvas');
var context = canvas.getContext("2d");
var text = document.getElementById("myText");

// Image1 is for redrawing the image
var image1 = new Image();
// Get the image name selected
var image_filename_multiple = {{image_url_multiple|safe}};
console.log("image_filename_multiple: ", image_filename_multiple);
var filenames_array = image_filename_multiple.split(",");
console.log("filenames_array: ", filenames_array);

// Get the name and path of all the selected images and store them
var filetype_index;
filetype_index = filenames_array[0].lastIndexOf(".");
var image_filename = filenames_array[0].substring(0,filetype_index+4);
var image_path = "/media/"+filenames_array[0].substring(0,filetype_index+4);
document.getElementById("show_imagename").innerHTML = filenames_array[0].substring(0,filetype_index+4)
// ! When deploying this website, replace all 127.0.0.1 in this html file with the ip of the server，
// Do the same in main.js
var axios_post_url = "http://127.0.0.1:8000/api/files/"


image1.src = image_path;
console.log("image_path")
console.log(image_path);

var canvas_height = 500;
var canvas_width;
var canvas_image_scale;
var image_draw_width;
var image_draw_height;
var detection_results_path = "/media/results/"+filenames_array[0].substring(0,filetype_index+4)+".txt";    //请求检测结果的路径
console.log("detection results path: ", detection_results_path);

var txt_download = filenames_array[0].substring(0,filetype_index);
var image_download_name = filenames_array[0].substring(0,filetype_index);

var text_from_ajax = "";
var array_convert = [];
var already_readtxt_flag = false;
var request_detection_results_flag = false;
var semi_detection_text;
var semi_detection_text_split;

// Read from text file, unused
function read_from_txt(){

    if((polygontemp.length!==0)||(polygonlist.length!==0)||(textreclist.length!==0))
    {alert("please load results before manual annotation");return;}
    //jquery ajax
    $.ajax({
        url: detection_results_path,
        dataType: 'text',
        async: false,
        success: function(data) {

          // split
          text_from_ajax = String(data);
          array_convert = text_from_ajax.split("$$&");
          console.log("array_convert: ", array_convert);
          console.log("ajax success");
          if((text_from_ajax.length!==0)){
            array_extract(array_convert,canvas_width, canvas_height);
            console.log("info from txt: ", array_convert);
            already_readtxt_flag = true;
            console.log("polygon list: ", polygonlist);
            console.log("textrec list: ", textreclist);
            console.log("text input list: ", textinputlist);
            redraw();
            redraw_textrec();
            redraw_text();}
        },
        error: function () { alert("no detection results found") }
    });
}

document.body.appendChild(canvas);

// Redraw the image
function redraw_image()
{
	context.drawImage(image1, 0, 0, image_draw_width, image_draw_height);
}

// The basic function of this canvas: please check the tutorial text files or videos in this project
// In short, this tool let user create new polygons to annotate the position of detected objects
// The user can edit the position, shape and color of existing polygons, delete polygons.
// The user can also create recognition results in a rectangle
// The position, color and size of the recognition results are decided by the editable rectangle
// To add recognition annotation, first create a rectangle then add text within it


// variables for the annotation tool
var polygonlist = [];
var polygontemp = [];
var polygon_i = 0;
var polygon_i1 = 0;
var polygon_selected;
var polygonvertex_selected;
var polygonpath_selected;
var temp_selected;
var index_circle;
var isDragging = false;
var isDraggingtemp = false;
var isPathDragging = false;
var deleteflag = false;
var deletetemp = false;
var color_change_flag = false;
var x_move;
var y_move;
var xmove_temp;
var ymove_temp;
var xmove_offset;
var ymove_offset;
var polygonindex_tocircle;
var vertex_count = 0;
var circle_radius = 2;
var circle_radius_select = 5;
var linewidth = 1.5;

var vertextemp1;
var circle1;

var distancefromcenter;

var textinput;
var textrec_setupflag = false;
var textinput_selected = false;
var textreclist = [];
var textrectemp = [];
var textrec_selected = 0;
var textrecvertex_selected;
var textpath_selected;
var isDragging_text = false;
var isPathDragging_text = false;
var deleteflag_text = false;

var x_move_text;
var y_move_text;
var xmove_temp_text;
var ymove_temp_text;
var xmove_offset_text;
var ymove_offset_text;

var textinput_temp;
var textinputlist = [];
var rec_width;
var rec_height;
var font_width;
var font_height;
var font_textinput;
var text_x;
var text_y;


var vertex_adding_selected = false;
var vertex_adding_flag = false;
var vertex_click_flag= false;
var vertex_adding_redraw = false;
var vertex_min_distance;
var vertex_selected_mindistance;
var polygon_selected_mindistance;

var vertex_between_1;
var vertex_between_2;
var vertex_between_3;

var draw_delete_flag = false;
var vertex_color = "blue";
var polygon_line_color = "green";
var polygon_selected_color = "black";
var text_selected_color = "yellow";
var text_rec_color = "green";
var text_color = "yellow";
var context_global_alpha = 1;
var text_vertex_color = "green";
var text_fontsize = 20;
var textrec_linewidth = 0.3;
var rec_width_temp;
var rec_height_temp;

var x0;
var x1;
var y0;
var y1;
var eng_number_length;
var polygon_index_list = [];
var textrec_index_list = [];
var text_index_flag = false;
var one_key_flag = false;
var text_save_index;
var text_save = "";
var colorchange_selected_flag = false;
var colorchange_polygon_flag = false;
var colorchange_text_flag = false;

// Below are the definition of different objects, like polygons or vertexes. etc

// Vertex
function Vertex(x,y)
{
	this.x = x;
	this.y = y;
}


// Circle
function Circle(x, y)
{
	this.x = x;
	this.y = y;
	this.radius = 10;
	this.color = "blue";
	this.isSelected = false;
}

// Polygon for detection results
function Polygon(vertexlist, color, has_textrec, textrec_index)
{
	this.vertexlist = vertexlist;
	this.color = color;
	this.has_textrec = has_textrec;
	this.textrec_index = textrec_index;
}

// Rectangle for determining the shape of position of recognition results
function Textrec(vertexlist, color, has_polygon, polygon_index)
{
	this.vertexlist = vertexlist;
	this.color = color;
	this.has_polygon = has_polygon;
	this.polygon_index = polygon_index;
}

// Recognition results
function Textinput(string_textinput, textrec_index)
{
	this.string_textinput = string_textinput;
	this.textrec_index = textrec_index;
}

// Read results in text files, currently unused
function array_extract(array_txt,width,height){

  if((polygonlist.length!==0)||(textreclist.length!==0))
  {alert("please load results before manual annotation");return;}

  for(var i = 0; i<array_txt.length;i = i+9){
    for(var i1 = 0; i1 < 8;i1= i1 + 2)
    {
      if(i1<6)
      {
        var vertex_store = new Vertex(array_txt[i+i1]*width,array_txt[i+i1+1]*height);
        polygontemp.push(vertex_store);
        if(i1===2){
          var text_numbers = array_txt[i+8];
          var vertex_bottomright = new Vertex(array_txt[i+i1]*width-10,array_txt[i+i1+1]*height-10);
          textrectemp.push(vertex_bottomright);
          var vertex_topleft = new Vertex((array_txt[i+i1]*width-10-(15*(array_txt[i+8].length))),(array_txt[i+i1+1]*height-30));
          textrectemp.push(vertex_topleft);
          textreclist.push(textrectemp);
          var textrec_index_store = new Textrec(textrectemp,"#00ff00",true,i/9);
          textrec_index_list.push(textrec_index_store);
          textrectemp = [];
        }
      }
      if(i1===6)
      {
        var vertex_store = new Vertex(array_txt[i+i1]*width,array_txt[i+i1+1]*height);
        polygontemp.push(vertex_store);
        polygonlist.push(polygontemp);
        var polygon_index_store = new Polygon(polygontemp, "#0033bb", true, i/9);
        polygon_index_list.push(polygon_index_store);
        polygontemp = [];
      }
    }

    var textinput_store = new Textinput(array_txt[i+8], i/9)
    textinputlist.push(textinput_store);
  }
}


// Canvas size
image1.addEventListener('load', function() {
	if(image1.height > 500)
	{
	  canvas_width = image1.width * (canvas_height/image1.height);
	  canvas_image_scale = canvas_height/image1.height;
		image_draw_width = image1.width*canvas_image_scale;
		image_draw_height = image1.height*canvas_image_scale;
		canvas.setAttribute("width",canvas_width);
		canvas.setAttribute("height",canvas_height);
		console.log("loadimage")
		context.drawImage(image1, 0, 0, image_draw_width, image_draw_height);
	}
	else
		{
			canvas_width = canvas_height * (image1.width/image1.height);
			canvas_image_scale = canvas_height/image1.height;
			image_draw_width = image1.width*canvas_image_scale;
			image_draw_height = image1.height*canvas_image_scale;
			canvas.setAttribute("width",canvas_width);
			canvas.setAttribute("height",canvas_height);
			context.drawImage(image1, 0, 0, image_draw_width, image_draw_height);
		}
}, false);

var next_image_count = 0;
var image2_width;
var image2_height;

var clickX_mousemove;
var clickY_mousemove;
var clickX_touchmove;
var clickY_touchmove;

var x_click_move ;
var y_click_move ;


// Switch to next image
function next_image()
{
  next_image_count = next_image_count + 1;
  if(next_image_count<filenames_array.length) {
    filetype_index = filenames_array[next_image_count].lastIndexOf(".");

    var index1=filenames_array[next_image_count].lastIndexOf(".");
    var index2=filenames_array[next_image_count].length;
    var suffix=filenames_array[next_image_count].substring(index1+1,index2);
    //console.log("suffix")
    //console.log(suffix)
    if(suffix==="jpg"||suffix==="png"||suffix==="bmp"||suffix==="jpeg"||
      suffix==="JPG"||suffix==="PNG"||suffix==="BMP"||suffix==="JPEG")
    {
    }else
    {alert("format: jpg png bmp");}

    image_filename = filenames_array[next_image_count].substring(1,filetype_index+4);
    image_path = "/media/"+filenames_array[next_image_count].substring(1,filetype_index+4);
    image_download_name = filenames_array[next_image_count].substring(1,filetype_index);
    document.getElementById("show_imagename").innerHTML = filenames_array[next_image_count].substring(1,filetype_index+4)
    var image2 = new Image();
    image2.src = image_path;
    image1.src = image_path;
    console.log("image path: ", image_path);

    canvas_height = 500;
    detection_results_path = "/media/results/"+filenames_array[next_image_count].substring(1,filetype_index+4)+".txt";
    txt_download = filenames_array[next_image_count].substring(1,filetype_index);
    // Reset the variables
    text_from_ajax = "";
    array_convert = [];
    already_readtxt_flag = false;
    polygonlist = [];

    polygontemp = [];
    textreclist = [];
    textrectemp = [];
    textinputlist = [];
    polygon_index_list = [];
    textrec_index_list = [];
    text_save = "";

    polygon_i = 0;

    polygon_i1 = 0;
    vertex_count = 0;

    isDragging = false;
    isDraggingtemp = false;
    isPathDragging = false;

    deleteflag = false;
    deletetemp = false;
    deleteflag_text = false;

    textrec_setupflag = false;
    textinput_selected = false;

    isDragging_text = false;
    isPathDragging_text = false;

    vertex_adding_selected = false;
    vertex_adding_flag = false;
    vertex_click_flag= false;
    vertex_adding_redraw = false;
    draw_delete_flag = false;
    text_index_flag = false;
    one_key_flag = false;

    color_change_flag = false;
    colorchange_selected_flag = false;
    colorchange_text_flag = false;
    colorchange_polygon_flag = false;

    image2.onload = function(){
      image2_width = image2.width;
      image2_height = image2.height;
      if(image2.height > 500)
	    {
	      canvas_width = image2.width * (canvas_height/image2.height);
	      canvas_image_scale = canvas_height/image2.height;
		    image_draw_width = image2.width*canvas_image_scale;
		    image_draw_height = image2.height*canvas_image_scale;
		    canvas.setAttribute("width",canvas_width);
		    canvas.setAttribute("height",canvas_height);
		    console.log("loadimage")
		    context.drawImage(image2, 0, 0, image_draw_width, image_draw_height);
	    }
	    else
		  {
			  canvas_width = canvas_height * (image2.width/image2.height);
			  canvas_image_scale = canvas_height/image2.height;
			  image_draw_width = image2.width*canvas_image_scale;
			  image_draw_height = image2.height*canvas_image_scale;
			  canvas.setAttribute("width",canvas_width);
			  canvas.setAttribute("height",canvas_height);
			  context.drawImage(image2, 0, 0, image_draw_width, image_draw_height);
		  }
    }
  }else{alert("This is the last image you selected")}
}

// ! Below are the functions for redrawing, everytime user make changes redraw everything


 function redraw(){
   // Redraw vertexes
		 for (polygon_i = 0; polygon_i < polygonlist.length; polygon_i++)
		 {
			 context.fillStyle = vertex_color;
			 context.strokeStyle = vertex_color;
			 context.lineWidth = linewidth;
			 context.setLineDash([]);
			 if (polygonlist[polygon_i].length > 2)
			 {
				 for (var i = 0; i < polygonlist[polygon_i].length; i++)
				 {
					 context.globalAlpha = 1;
					 context.beginPath();
					 context.lineWidth = linewidth;
					 context.arc( polygonlist[polygon_i][i].x, polygonlist[polygon_i][i].y, circle_radius, 0, Math.PI * 2);

					 context.fill();
					 context.stroke();
				 }
			 }
		 }
   // Redraw polygons
	 for (polygon_i = 0; polygon_i < polygonlist.length; polygon_i++)
	 {
		 context.fillStyle = polygon_index_list[polygon_i].color;
		 context.strokeStyle = polygon_index_list[polygon_i].color;
		 context.setLineDash([]);
		 draw_delete_flag = ((polygon_i === polygon_selected)&&deleteflag)
		 if(((vertex_adding_flag === true)&&(vertex_adding_redraw = true)&&(polygon_i === polygonpath_selected)))
		 {
			 context.fillStyle = polygon_selected_color;
			 context.strokeStyle = polygon_selected_color;
			 context.setLineDash([3, 9]);
			 if(polygon_i === polygon_selected)
			 {
				 context.setLineDash([]);
			 }
		 }
		 if (polygonlist[polygon_i].length > 1)
		 {
			 context.beginPath();
			 context.lineWidth = linewidth;
			 context.moveTo(polygonlist[polygon_i][0].x, polygonlist[polygon_i][0].y);
			 for (var i = 1; i < polygonlist[polygon_i].length; i++)
			 {
				 if (i < (polygonlist[polygon_i].length - 1))
				 {
					 context.lineTo(polygonlist[polygon_i][i].x, polygonlist[polygon_i][i].y);
				 }
				 if (i === (polygonlist[polygon_i].length - 1))
				 {
					 context.lineTo(polygonlist[polygon_i][i].x, polygonlist[polygon_i][i].y);
					 context.closePath();
					 context.stroke();
				 }
			 }
		 }
		 context.setLineDash([]);
	 }
	 for(var i = 0; i<polygontemp.length;i++)
	 {
		 context.globalAlpha = 1;
		 context.beginPath();
		 context.lineWidth = linewidth;
		 context.arc( polygontemp[i].x, polygontemp[i].y, circle_radius, 0, Math.PI * 2);
		 context.fillStyle = vertex_color;
		 context.strokeStyle = vertex_color;
		 context.fill();
		 context.stroke();
	 }

 }

// Redraw the polygons and use the IsPointInPath method to see if the click position is in a polygon
function redraw_inpath(x,y){

	for (polygon_i = 0; polygon_i < polygonlist.length; polygon_i++)
	{
		if (polygonlist[polygon_i].length > 2) {
			for (var i = 0; i < polygonlist[polygon_i].length; i++)
			{
				context.globalAlpha = 1;
				context.beginPath();
				context.lineWidth = linewidth;
				context.arc( polygonlist[polygon_i][i].x, polygonlist[polygon_i][i].y, circle_radius, 0, Math.PI * 2);
				context.fillStyle = vertex_color;
				context.strokeStyle = vertex_color;
				context.fill();
				context.stroke();
			}
		}
	}

	for (polygon_i = 0; polygon_i < polygonlist.length; polygon_i++)
	{
		context.fillStyle = polygon_index_list[polygon_i].color;
		context.strokeStyle = polygon_index_list[polygon_i].color;
		//context.setLineDash([]);
		draw_delete_flag = ((polygon_i === polygon_selected)&&deleteflag)
		if(((vertex_adding_flag === true)&&(vertex_adding_redraw = true)&&(polygon_i === polygonpath_selected)))
		{
			context.fillStyle = polygon_selected_color;
			context.strokeStyle = polygon_selected_color;
			//context.setLineDash([3, 9]);
			if(polygon_i === polygon_selected)
			{
				//context.setLineDash([]);
			}
		}

		if (polygonlist[polygon_i].length > 1) {

			context.beginPath();
			context.lineWidth = linewidth;
			context.moveTo(polygonlist[polygon_i][0].x, polygonlist[polygon_i][0].y);

			for (var i = 1; i < polygonlist[polygon_i].length; i++)
			{
				if (i < (polygonlist[polygon_i].length - 1))
				{
					context.lineTo(polygonlist[polygon_i][i].x, polygonlist[polygon_i][i].y);
				}
				if (i === (polygonlist[polygon_i].length - 1))
				{
					context.lineTo(polygonlist[polygon_i][i].x, polygonlist[polygon_i][i].y);
					context.closePath();
					// use IsPointInpath to see if the click position is in the interior of a polygon
					if (context.isPointInPath(x, y))
					{
						if(text_index_flag === false)
						{
							polygonpath_selected = polygon_i;
						}
						if(text_index_flag === true)
						{
							polygonpath_selected = polygon_i;
							if(polygon_index_list[polygonpath_selected].has_textrec === false)
							{
								polygon_index_list[polygonpath_selected].has_textrec = true;
								polygon_index_list[polygonpath_selected].textrec_index = textpath_selected;
								textrec_index_list[textpath_selected].has_polygon = true;
								textrec_index_list[textpath_selected].polygon_index = polygonpath_selected;
								text_index_flag = false;
								console.log("polygon: ", polygon_index_list[polygonpath_selected]);
								console.log("textrec: ", textrec_index_list[textpath_selected]);
								context.clearRect(0, 0, canvas.width, canvas.height);
								redraw_image();
								redraw();
								redraw_textrec();
								redraw_text();
								return;
							}
						}
						deleteflag = false;
						if(text_index_flag === false)
						{
							isPathDragging = true;
						}
					}
					context.stroke();
				}
			}
		}
	}

	for(var i = 0; i<polygontemp.length;i++)
	{
		context.globalAlpha = 1;
		context.beginPath();
		context.arc( polygontemp[i].x, polygontemp[i].y, circle_radius, 0, Math.PI * 2);
		context.fillStyle = vertex_color;
		context.strokeStyle = vertex_color;
		context.fill();
		context.stroke();
	}
}

// Redraw the rectangles
function redraw_textrec()
{
	for (var i = 0; i < textrectemp.length; i++)
	{
		context.globalAlpha = 1;
		context.lineWidth = textrec_linewidth;
		context.beginPath();
		context.arc( textrectemp[i].x, textrectemp[i].y, circle_radius, 0, Math.PI * 2);
		context.fillStyle = text_vertex_color;
		context.strokeStyle = text_vertex_color;
		//context.setLineDash([]);
		context.fill();
		context.stroke();
	}

	for (textrec_i1 = 0; textrec_i1 < textreclist.length; textrec_i1++)
	{
			for (var i = 0; i < 2; i++)
			{
				context.globalAlpha = 1;
				context.beginPath();
				context.arc( textreclist[textrec_i1][i].x, textreclist[textrec_i1][i].y, circle_radius, 0, Math.PI * 2);
				context.fillStyle = text_vertex_color;
				context.strokeStyle = text_vertex_color;
				//context.setLineDash([]);
				context.fill();
				context.stroke();
			}
	}

	for (textrec_i1 = 0; textrec_i1 < textreclist.length; textrec_i1++)
	{
		context.fillStyle = textrec_index_list[textrec_i1].color;
		context.strokeStyle = textrec_index_list[textrec_i1].color;
    if((text_index_flag === true)&&(textrec_i1 === textpath_selected))
    {
			context.fillStyle = "purple";
			context.strokeStyle = "purple";
		}else
			{
				context.fillStyle = textrec_index_list[textrec_i1].color;
				context.strokeStyle = textrec_index_list[textrec_i1].color;
			}

		if (textreclist[textrec_i1].length > 1)
		{
			context.beginPath();
			context.lineWidth = linewidth;
			context.moveTo(textreclist[textrec_i1][0].x, textreclist[textrec_i1][0].y);

			for (var i = 1; i < 4; i++)
			{
				if (i === 1)
				{
					context.lineTo(textreclist[textrec_i1][1].x,textreclist[textrec_i1][0].y);
				}
				if (i === 2)
				{
					context.lineTo(textreclist[textrec_i1][1].x,textreclist[textrec_i1][1].y);
				}
				if (i === 3)
				{
					context.lineTo(textreclist[textrec_i1][0].x,textreclist[textrec_i1][1].y);
					context.closePath();
					context.stroke();
				}
			}
		}
	}
}

// Redraw the rectangles and see if the click position is within the interior of a rectangle
function redraw_inpath_textrec(x,y)
{
	for (var i = 0; i < textrectemp.length; i++)
	{
		context.globalAlpha = 1;
		context.lineWidth = textrec_linewidth;
		context.beginPath();
		context.arc( textrectemp[i].x, textrectemp[i].y, circle_radius, 0, Math.PI * 2);
		context.fillStyle = text_vertex_color;
		context.strokeStyle = text_vertex_color;
		//context.setLineDash([]);
		context.fill();
		context.stroke();
	}

	for (textrec_i1 = 0; textrec_i1 < textreclist.length; textrec_i1++)
	{
		for (var i = 0; i < 2; i++)
		{
			context.globalAlpha = 1;
			context.beginPath();
			context.arc( textreclist[textrec_i1][i].x, textreclist[textrec_i1][i].y, circle_radius, 0, Math.PI * 2);
			context.fillStyle = text_vertex_color;
			context.strokeStyle = text_vertex_color;
			//context.setLineDash([]);
			context.fill();
			context.stroke();
		}
	}

	for (textrec_i1 = 0; textrec_i1 < textreclist.length; textrec_i1++)
	{
		context.fillStyle = textrec_index_list[textrec_i1].color;
		context.strokeStyle = textrec_index_list[textrec_i1].color;
    if((text_index_flag === true)&&(textrec_i1 === textpath_selected))
    {
      //context.setLineDash(5,15);
			context.fillStyle = "purple";
			context.strokeStyle = "purple";
		}else
			{
				context.fillStyle = textrec_index_list[textrec_i1].color;
				context.strokeStyle = textrec_index_list[textrec_i1].color;
				//context.setLineDash([]);
			}


		if (textreclist[textrec_i1].length > 1)
		{

			context.beginPath();
			context.lineWidth = linewidth;
			context.moveTo(textreclist[textrec_i1][0].x, textreclist[textrec_i1][0].y);

			for (var i = 1; i < 4; i++)
			{
				if (i === 1) {
					context.lineTo(textreclist[textrec_i1][1].x,textreclist[textrec_i1][0].y);
				}
				if (i === 2) {
					context.lineTo(textreclist[textrec_i1][1].x,textreclist[textrec_i1][1].y);
				}
				if (i === 3)
				{
					context.lineTo(textreclist[textrec_i1][0].x,textreclist[textrec_i1][1].y);
					context.closePath();
					if (context.isPointInPath(x, y))
					{
						if(text_index_flag === false)
						{
							textpath_selected = textrec_i1;
						}

						if(text_index_flag === true)
						{
							if(textpath_selected === textrec_i1)
							{
								text_index_flag = false;
								context.clearRect(0, 0, canvas.width, canvas.height);
								//context.fillStyle = text_rec_color;
								//context.strokeStyle = text_rec_color;
								redraw_image();
								redraw();
								redraw_textrec();
								redraw_text();
								return;
							}
						}
						deleteflag = false;
						isDragging = false;
						isDraggingtemp = false;
						isPathDragging = false;
						deletetemp = false;
						if(text_index_flag === false)
						{
							textinput_selected = true;
							isPathDragging_text = true;
						}
						isDragging_text = false;
						deleteflag_text = false;
					}
					context.stroke();
				}
			}
		}
	}
}

// redraw the recognition results within the rectangles
function redraw_text()
{
	for(var i = 0; i<textinputlist.length;i++)
	{
		var index_textrec = textinputlist[i].textrec_index;
		context.fillStyle = textrec_index_list[index_textrec].color;
		context.strokeStyle = textrec_index_list[index_textrec].color;
		context.lineWidth = linewidth;
		x0 = textreclist[index_textrec][0].x;
		x1 = textreclist[index_textrec][1].x;
		y0 = textreclist[index_textrec][0].y;
		y1 = textreclist[index_textrec][1].y;
		rec_width = Math.abs(x0 - x1);
		rec_height = Math.abs(y0 - y1);

		const re = /[a-z0-9A-Z]/g;
		eng_number_length = ((textinputlist[i].string_textinput || '').match(re) || []).length;
		font_width = 0.95*Math.floor(rec_width/textinputlist[i].string_textinput.length)
		//console.log(textinputlist[i].string_textinput.length);
		font_height = 0.95*rec_height;
		font_textinput = Math.min(font_width,font_height);

		if(x0>x1)
		{text_x = x1 + 0.5*(Math.abs(x0 - x1) - (textinputlist[i].string_textinput.length - 0.5*eng_number_length) * font_textinput);}
		else {text_x = x0 + 0.5*(Math.abs(x0 - x1) - (textinputlist[i].string_textinput.length - 0.5*eng_number_length) * font_textinput);}
		if(y0>y1)
		{text_y = y0 - 0.5*(Math.abs(y0-y1) - font_textinput);}
		else {text_y = y1 - 0.5*(Math.abs(y0-y1) - font_textinput);}
		context.font= font_textinput + "px monospace";
		if(eng_number_length === 0)
		{context.fillText(textinputlist[i].string_textinput,(text_x),(text_y - (rec_height / 8)));
		}
		if(eng_number_length === textinputlist[i].string_textinput.length)
		{context.fillText(textinputlist[i].string_textinput,(text_x),(text_y - (rec_height / 8)));
		}
    if((eng_number_length !== 0)&&(eng_number_length !== textinputlist[i].string_textinput.length))
    {context.fillText(textinputlist[i].string_textinput,(text_x),(text_y - (rec_height / 8)));
		}
	}
}

// ! Below are some functions of the keyboard
// keyboard E
function E_keyboard()
{
    /*		context.clearRect(0,0,canvas.width,canvas.height);
        redraw();
        redraw_textrec();
        redraw_text();*/
    one_key_flag = true;
		textinput_selected = false;
    if(deleteflag_text === false)
    {
      if (deletetemp === true)
			{

				polygontemp.splice((temp_selected), 1);
				context.clearRect(0, 0, canvas.width, canvas.height);
				redraw_image();
				redraw();
				redraw_textrec();
				redraw_text();
			}

			if (deletetemp === false)
			{
				polygonlist.splice((polygon_selected), 1);
				polygon_index_list.splice((polygon_selected), 1);
        for(var i = 0; i < textrec_index_list.length; i++)
        {
					if(textrec_index_list[i].polygon_index === polygon_selected)
					{
						textrec_index_list[i].polygon_index = -1;
						textrec_index_list[i].has_polygon = false;
					}
          if(textrec_index_list[i].polygon_index > polygon_selected)
          {
						textrec_index_list[i].polygon_index = textrec_index_list[i].polygon_index - 1;
					}
				}
        console.log("textrec_index_list: ", textrec_index_list);
				context.clearRect(0, 0, canvas.width, canvas.height);
				redraw_image();
				redraw();
				redraw_textrec();
				redraw_text();
			}
			context.clearRect(0, 0, canvas.width, canvas.height);
			redraw_image();
			redraw();
			redraw_textrec();
			redraw_text();

			deleteflag = false;
			deleteflag_text =false;
		}

    if(deleteflag_text === true)
    {
      var text_delete_temp;
      textreclist.splice(textrec_selected,1);
      textrec_index_list.splice(textrec_selected, 1);

      for(var i = 0; i < polygon_index_list.length; i++)
      {
        if(polygon_index_list[i].textrec_index === textrec_selected)
        {
					polygon_index_list[i].textrec_index = -1;
					polygon_index_list[i].has_textrec = false;
				}
				if(polygon_index_list[i].textrec_index > textrec_selected)
				{
					polygon_index_list[i].textrec_index = polygon_index_list[i].textrec_index - 1;
				}
			}
			for(var i = 0; i < textinputlist.length; i++)
			{
				if(textinputlist[i].textrec_index === textrec_selected)
				{
					text_delete_temp = i;
					textinputlist.splice(text_delete_temp,1);
				}
			}
			for(var i = 0; i < textinputlist.length; i++)
			{
				if(textinputlist[i].textrec_index > textrec_selected)
				{
					textinputlist[i].textrec_index = textinputlist[i].textrec_index - 1;
				}
			}

			console.log("textinput list: ", textinputlist);
			console.log("polygon_index_list: ", polygon_index_list);
			context.clearRect(0, 0, canvas.width, canvas.height);
			redraw_image();
			redraw();
			redraw_textrec();
			redraw_text();
			deleteflag = false;
			deleteflag_text = false;
			one_key_flag = false;
		}
}

// keyboard F
function F_keyboard()
{
    one_key_flag = true;
		polygonlist.push(polygontemp);
		var polygon_index_temp = new Polygon(polygontemp, "#0033bb", false, -1);
		polygon_index_list.push(polygon_index_temp);
		polygontemp = [];
		context.clearRect(0, 0, canvas.width, canvas.height);
    redraw_image();
		redraw();
    redraw_textrec();
    redraw_text();

		deleteflag = false;
		isDragging = false;
		isDraggingtemp = false;
		isPathDragging = false;
		deletetemp = false;
		isDragging_text = false;
		isPathDragging_text = false;
		deleteflag_text = false;
		textinput_selected = false;
    one_key_flag = false;
}

// keyboard Enter
function Enter_keyboard()
{
    one_key_flag = true;
		textinput_selected = false;
		var stringtext = document.getElementById("myText").value;
		var text_edit_flag = false;
		for(var i = 0; i < textinputlist.length; i++)
		{
			if(textinputlist[i].textrec_index === textpath_selected)
			{
				textinputlist[i].string_textinput = stringtext;
				text_edit_flag = true;
			}
		}

		if(text_edit_flag === false)
		{
			textinput_temp = new Textinput(stringtext,textpath_selected);
			textinputlist.push(textinput_temp);
		}

		context.clearRect(0,0,canvas.width,canvas.height);
		redraw_image();
		redraw();
		redraw_textrec();
		redraw_text();

		deleteflag = false;
		deletetemp = false;
		deleteflag_text = false;
		isDragging = false;
		isDraggingtemp = false;
		isPathDragging = false;
		isDragging_text = false;
		isPathDragging_text = false;
    one_key_flag = false;
}

// keyboard events
var keysDown = {};

addEventListener("keydown", function (e) {
	keysDown[e.keyCode] = true;
}, false);

addEventListener("keyup", function (e) {
  //F
	if((one_key_flag === false)&&
		(70 in keysDown)&&(polygontemp.length>2)&&(isDragging === false)&&(isPathDragging === false)&&(textinput_selected === false)
		&&(document.getElementById("myText") !== document.activeElement)&&(vertex_adding_flag === false)&&(color_change_flag === false))
	{
	  F_keyboard();
	}
  //E
	if((one_key_flag === false)&&
		(69 in keysDown)&&(isDragging === false)&&(isPathDragging === false)&&(deleteflag === true)&&(textinput_selected === false)
		&&(document.getElementById("myText") !== document.activeElement)&&(vertex_adding_flag === false)&&(color_change_flag === false))
	{
     E_keyboard();
	}
	//T
	if((one_key_flag === false)&&
		(84 in keysDown)&&(isDragging === false)&&(isPathDragging === false)
		&&(document.getElementById("myText") !== document.activeElement)&&(vertex_adding_flag === false)&&(color_change_flag === false))
	{
	  one_key_flag = true;
		textrec_setupflag = !(textrec_setupflag);
		one_key_flag = false;
	}
    //A
	if((one_key_flag === false)&&
		(65 in keysDown)&&(isDragging === false)&&(isPathDragging === false)
		&&(document.getElementById("myText") !== document.activeElement)&&(vertex_adding_flag === true)&&(color_change_flag === false))
	{
	  one_key_flag = true;
		vertex_adding_flag = !(vertex_adding_flag);
		one_key_flag = false;
	}
    //Enter
	if((one_key_flag === false)&&
		(13 in keysDown)&&(isDragging === false)&&(isPathDragging === false)&&(textinput_selected === true)&&(vertex_adding_flag === false)&&(color_change_flag === false))
	{
	  Enter_keyboard();
	}
	//save
	if((one_key_flag === false)&&(document.getElementById("myText") !== document.activeElement)&&
		(83 in keysDown)&&(isDragging === false)&&(isPathDragging === false)&&(vertex_adding_flag === false)&&(color_change_flag === false))
	{
	  one_key_flag = true;
	  save_txt_vertexes_and_text()
	  one_key_flag = false;
  }
	//post
  if((one_key_flag === false)&&(document.getElementById("myText") !== document.activeElement)&&
    (80 in keysDown)&&(isDragging === false)&&(isPathDragging === false)&&(vertex_adding_flag === false)&&(color_change_flag === false))
	{
    one_key_flag = true;
    post_txt_vertexes_and_text()
	  one_key_flag = false;
  }
  //N
  if((one_key_flag === false)&&(document.getElementById("myText") !== document.activeElement)&&
    (78 in keysDown)&&(isDragging === false)&&(isPathDragging === false)&&(vertex_adding_flag === false)&&(color_change_flag === false))
	{
    one_key_flag = true;
    next_image()
	  one_key_flag = false;
  }
  //D
  if((one_key_flag === false)&&(document.getElementById("myText") !== document.activeElement)&&
    (68 in keysDown)&&(isDragging === false)&&(isPathDragging === false)&&(vertex_adding_flag === false)&&(color_change_flag === false))
	{
    one_key_flag = true;
    upload_east_detection_path()
	  one_key_flag = false;
  }
	delete keysDown[e.keyCode];
	context.clearRect(0,0,canvas.width,canvas.height);
	redraw_image();
  redraw();
  redraw_textrec();
  redraw_text();
  one_key_flag = false;
}, false);

// The function for mousemove and touchstart event
function mousedown_function(clickX,clickY)
{
  // First detect whether the click position is on any polygon, rectangle or vertex
  // If none is selected by the user click, create a new vertex
  if ((vertex_adding_flag === false)&&(text_index_flag === false))
    {
		for (polygon_i1 = 0; polygon_i1 < polygonlist.length; polygon_i1++) {
			for (var i = 0; i < polygonlist[polygon_i1].length; i++) {
				distancefromcenter = Math.sqrt(Math.pow(polygonlist[polygon_i1][i].x - clickX, 2)
					+ Math.pow(polygonlist[polygon_i1][i].y - clickY, 2));
				if (distancefromcenter < circle_radius_select)
				{
					polygonvertex_selected = i;
					polygon_selected = polygon_i1;

					deleteflag = true;
					deletetemp = false;
					deleteflag_text = false;
          colorchange_selected_flag = true;
          colorchange_polygon_flag = true;
          colorchange_text_flag = false;
					isDragging = true;
					isDraggingtemp = false;
					isPathDragging = false;
					isDragging_text = false;
					isPathDragging_text = false;
					textinput_selected = false;
					//停止搜索
					return;
				}

			}
		}
		for (var i = 0; i < polygontemp.length; i++) {
			distancefromcenter = Math.sqrt(Math.pow(polygontemp[i].x - clickX, 2)
				+ Math.pow(polygontemp[i].y - clickY, 2));
			if (distancefromcenter < circle_radius_select)
			{
				temp_selected = i;
				deleteflag = false;
				deletetemp = true;
				deleteflag_text = false;
				isDragging = false;
				isDraggingtemp = true;
				isPathDragging = false;
				isDragging_text = false;
				isPathDragging_text = false;
				textinput_selected = false;
				return;
			}
		}

		for (textrec_i1 = 0; textrec_i1 < textreclist.length; textrec_i1++) {
			for (var i = 0; i < 2; i++) {
				distancefromcenter = Math.sqrt(Math.pow(textreclist[textrec_i1][i].x - clickX, 2)
					+ Math.pow(textreclist[textrec_i1][i].y - clickY, 2));
				if (distancefromcenter < circle_radius_select)
				{
					textrecvertex_selected = i;
					textrec_selected = textrec_i1;

					deleteflag = true;
					deletetemp = false;
					deleteflag_text = true;
          colorchange_selected_flag = true;
          colorchange_text_flag = true;
          colorchange_polygon_flag = false;
					isDragging = false;
					isDraggingtemp = false;
					isPathDragging = false;
					isDragging_text = true;
					isPathDragging_text = false;
					textinput_selected = false;
					return;
				}
			}
		}

		for (var i = 0; i < textrectemp.length; i++) {
			distancefromcenter = Math.sqrt(Math.pow(textrectemp[i].x - clickX, 2)
				+ Math.pow(textrectemp[i].y - clickY, 2));
			if (distancefromcenter < circle_radius_select)
			{
				deleteflag = false;
				deleteflag_text = false;
				deletetemp = false;
        colorchange_selected_flag = true;
				isDragging = false;
				isDraggingtemp = false;
				isPathDragging = false;
				isDragging_text = false;
				isPathDragging_text = false;
				textinput_selected = false;
				return;
			}
		}

		context.clearRect(0, 0, canvas.width, canvas.height);
		// If the interior of a polygon or textrec is selected
		redraw_image();
		redraw_inpath(clickX, clickY);
		redraw_inpath_textrec(clickX, clickY);
		redraw_text();
		// the click position is in the interior of a polygon
		if (isPathDragging === true)
		{
			xmove_temp = clickX;
			ymove_temp = clickY;
      //console.log("set path dragging polygon")
			deleteflag = false;
			deletetemp = false;
			deleteflag_text = false;
			isDragging = false;
			isDraggingtemp = false;
			isPathDragging = true;
      isDragging_text = false;
			isPathDragging_text = false;
			textinput_selected = false;
			vertex_adding_selected = true;
			vertex_adding_flag = true;
			return;
		}
    // The click position is in the interior of a rectangle
		if (isPathDragging_text === true)
		{
			xmove_temp_text = clickX;
			ymove_temp_text = clickY;
      //console.log("set path dragging text")
			deleteflag = false;
      deletetemp = false;
      deleteflag_text = false;
			isDragging = false;
			isDraggingtemp = false;
			isPathDragging = false;
			isDragging_text = false;
			isPathDragging_text = true;
			textinput_selected = true;
			if(textrec_index_list[textpath_selected].has_polygon === false)
			{
				text_index_flag = true;
			}
			return;
		}

		if (textrec_setupflag === false)
		{
			vertextemp1 = new Vertex(clickX, clickY);
			polygontemp.push(vertextemp1);

			deleteflag = false;
      deletetemp = false;
      deleteflag_text = false;
			isDragging = false;
			isDraggingtemp = false;
			isPathDragging = false;
			isDragging_text = false;
			isPathDragging_text = false;
			textinput_selected = false;
		}

		if (textrec_setupflag === true)
		{
			vertextemp1 = new Vertex(clickX, clickY);
			textrectemp.push(vertextemp1);
			if (textrectemp.length > 1)
			{
				textreclist.push(textrectemp);
				var textrec_index_temp = new Textrec(textrectemp, "#00ff00", false, -1);
				textrec_index_list.push(textrec_index_temp);
				textrectemp = [];
			}
			deleteflag = false;
      deletetemp = false;
      deleteflag_text = false;
			isDragging = false;
			isDraggingtemp = false;
			isPathDragging = false;
			isDragging_text = false;
			isPathDragging_text = false;
			textinput_selected = false;
		}
		context.clearRect(0, 0, canvas.width, canvas.height);
		redraw_image();
		redraw();
		redraw_textrec();
		redraw_text();
		return;
	}
    // vertex_adding_flag === true, add vertexes to an existing polygon
    if((vertex_adding_flag === true)&&(text_index_flag === false))
    {
    	vertex_click_flag = true;

		for (var i = 0; i < polygonlist[polygonpath_selected].length; i++)
		{
			distancefromcenter = Math.sqrt(Math.pow(polygonlist[polygonpath_selected][i].x - clickX, 2)
				+ Math.pow(polygonlist[polygonpath_selected][i].y - clickY, 2));
			if (distancefromcenter < circle_radius_select)
			{
				return;
			}
			if(i === 0)
			{
				vertex_min_distance = distancefromcenter;
			}
			if(distancefromcenter<vertex_min_distance)
			{
				vertex_min_distance = distancefromcenter;
				vertex_selected_mindistance = i;
				vertex_adding_redraw = true;
			}
		}
		var vertex_add = new Vertex(clickX, clickY);
		vertex_between_1 = polygonlist[polygonpath_selected][vertex_selected_mindistance];
		if(vertex_selected_mindistance !== (polygonlist[polygonpath_selected].length-1))
		{
			vertex_between_2 = polygonlist[polygonpath_selected][vertex_selected_mindistance+1];
		}
		if(vertex_selected_mindistance === (polygonlist[polygonpath_selected].length-1))
		{
			vertex_between_2 = polygonlist[polygonpath_selected][0];
		}
		if(vertex_selected_mindistance !== 0)
		{
			vertex_between_3 = polygonlist[polygonpath_selected][vertex_selected_mindistance-1];
		}
		if(vertex_selected_mindistance === 0)
		{
			vertex_between_3 = polygonlist[polygonpath_selected][polygonlist[polygonpath_selected].length-1];
		}
		var x1 = vertex_between_1;
		var x2 = vertex_between_2;
		var x3 = vertex_between_3;
		var judge1 = ((x_move < x1.x) && (x_move > x3.x)) || ((x_move > x1.x) && (x_move < x3.x));
		var judge2 = ((y_move < x1.y) && (y_move > x3.y)) || ((y_move > x1.y) && (y_move < x3.y));
		if((!judge1) && (!judge2))
		{
			if(vertex_selected_mindistance !== (polygonlist[polygonpath_selected].length-1))
			{
				vertex_selected_mindistance = vertex_selected_mindistance+1;
			}
			if(vertex_selected_mindistance === (polygonlist[polygonpath_selected].length-1))
			{
				vertex_selected_mindistance = 0;
			}
		}
		//添加顶点
		polygonlist[polygonpath_selected].splice(vertex_selected_mindistance,0,vertex_add);
		//console.log(polygonlist[polygonpath_selected]);
		context.clearRect(0, 0, canvas.width, canvas.height);
		redraw_image();
		redraw();
		redraw_textrec();
		redraw_text();
		vertex_click_flag = false;
		return;
	}

	if((vertex_adding_flag === false)&&(text_index_flag === true))
	{
		context.clearRect(0, 0, canvas.width, canvas.height);
		// The code of creating the one-to-one relationship between polygon and rectangle is in the below functions
		redraw_image();
		redraw_inpath_textrec(clickX, clickY);
		redraw_inpath(clickX,clickY);
		redraw_text();
	}
}

// The function for mousemove and touchmove
function mousemove_function(x1_move,y1_move)
{
  if((vertex_adding_flag === true)&&(vertex_click_flag === false)&&(isPathDragging === false))
	{
		x_move = x1_move;
		y_move = y1_move;

		for (var i = 0; i < polygonlist[polygonpath_selected].length; i++)
		{
			distancefromcenter = Math.sqrt(Math.pow(polygonlist[polygonpath_selected][i].x - x_move, 2)
				+ Math.pow(polygonlist[polygonpath_selected][i].y - y_move, 2));
			if(i === 0)
			{
				vertex_min_distance = distancefromcenter;
			}
			if((i !== 0)&&(distancefromcenter<(vertex_min_distance)))
			{
				vertex_min_distance = distancefromcenter;
				vertex_selected_mindistance = i;
				vertex_adding_redraw = true;
			}
		}
		var vertex_add = new Vertex(x_move, y_move);
		 vertex_between_1 = polygonlist[polygonpath_selected][vertex_selected_mindistance];
		 if(vertex_selected_mindistance !== (polygonlist[polygonpath_selected].length-1))
		 {
		 	  vertex_between_2 = polygonlist[polygonpath_selected][vertex_selected_mindistance+1];
		 }
		 if(vertex_selected_mindistance === (polygonlist[polygonpath_selected].length-1))
		 {
		 	  vertex_between_2 = polygonlist[polygonpath_selected][0];
		 }
		if(vertex_selected_mindistance !== 0)
		{
			  vertex_between_3 = polygonlist[polygonpath_selected][vertex_selected_mindistance-1];
		}
		if(vertex_selected_mindistance === 0)
		{
			  vertex_between_3 = polygonlist[polygonpath_selected][polygonlist[polygonpath_selected].length-1];
		}
		var x1 = vertex_between_1;
		var x2 = vertex_between_2;
		var x3 = vertex_between_3;

		var judge1 = ((x_move < x1.x) && (x_move > x3.x)) || ((x_move > x1.x) && (x_move < x3.x));
		var judge2 = ((y_move < x1.y) && (y_move > x3.y)) || ((y_move > x1.y) && (y_move < x3.y));
		if((!judge1) && (!judge2))
		{
			//console.log("change index vertex 3");
			//console.log(vertex_between_3);
			if(vertex_selected_mindistance !== (polygonlist[polygonpath_selected].length-1))
			{
				vertex_selected_mindistance = vertex_selected_mindistance+1;
			}
			if(vertex_selected_mindistance === (polygonlist[polygonpath_selected].length-1))
			{
				vertex_selected_mindistance = 0;
			}
		}
		polygonlist[polygonpath_selected].splice(vertex_selected_mindistance,0,vertex_add);
    //console.log("drawing dotted line")
		context.clearRect(0, 0, canvas.width, canvas.height);
		redraw_image();
		redraw();
		redraw_textrec();
		redraw_text();
		polygonlist[polygonpath_selected].splice(vertex_selected_mindistance,1);
	}

	if ((isDragging === true))
	{
    deleteflag = false;
		vertex_adding_selected = false;
		vertex_adding_flag = false;
		text_index_flag = false;
		x_move = x1_move;
		y_move = y1_move;
		polygonlist[polygon_selected][polygonvertex_selected].x = x_move;
		polygonlist[polygon_selected][polygonvertex_selected].y = y_move;
		context.clearRect(0, 0, canvas.width, canvas.height);
		redraw_image();
    redraw();
    redraw_textrec();
    redraw_text();
	}
	if ((isDraggingtemp === true))
	{
		deleteflag = false;
		vertex_adding_selected = false;
		vertex_adding_flag = false;
		text_index_flag = false;
		x_move = x1_move;
		y_move = y1_move;
		polygontemp[temp_selected].x = x_move;
		polygontemp[temp_selected].y = y_move;
		context.clearRect(0, 0, canvas.width, canvas.height);
		redraw_image();
		redraw();
		redraw_textrec();
		redraw_text();
	}
	// isDragging结束
	if(isPathDragging===true)
	{
		deleteflag = false;
		vertex_adding_selected = false;
		vertex_adding_flag = false;
		text_index_flag = false;
		x_move = x1_move;
		y_move = y1_move;
    //console.log("x_move: ", x_move)
    //console.log("y_move: ", y_move)
		xmove_offset = x_move - xmove_temp;
		ymove_offset = y_move - ymove_temp;
		xmove_temp = x_move;
		ymove_temp = y_move;
		vertex_count = 0;
    for (var i = 0; i<polygonlist[polygonpath_selected].length; i++)
		{
			polygonlist[polygonpath_selected][i].x = polygonlist[polygonpath_selected][i].x + xmove_offset;
			polygonlist[polygonpath_selected][i].y = polygonlist[polygonpath_selected][i].y + ymove_offset;
		}
		context.clearRect(0, 0, canvas.width, canvas.height);
		redraw_image();
    redraw();
    redraw_textrec();
    redraw_text();
	}
	if(isDragging_text === true)
	{
		deleteflag = false;
		vertex_adding_selected = false;
		vertex_adding_flag = false;
		text_index_flag = false;
		x_move_text = x1_move;
		y_move_text = y1_move;

		textreclist[textrec_selected][textrecvertex_selected].x = x_move_text;
		textreclist[textrec_selected][textrecvertex_selected].y = y_move_text;
		context.clearRect(0, 0, canvas.width, canvas.height);
		redraw_image();
		redraw();
		redraw_textrec();
		redraw_text();
	}
	if(isPathDragging_text === true)
	{
		deleteflag = false;
		vertex_adding_selected = false;
		vertex_adding_flag = false;
		text_index_flag = false;
		x_move_text = x1_move;
		y_move_text = y1_move;
		xmove_offset_text = x_move_text - xmove_temp_text;
		ymove_offset_text = y_move_text - ymove_temp_text;
		xmove_temp_text = x_move_text;
		ymove_temp_text = y_move_text;

		for (var i = 0; i<2; i++)
		{
			textreclist[textpath_selected][i].x = textreclist[textpath_selected][i].x + xmove_offset_text;
			textreclist[textpath_selected][i].y = textreclist[textpath_selected][i].y + ymove_offset_text;
		}
		context.clearRect(0, 0, canvas.width, canvas.height);
		redraw_image();
		redraw();
		redraw_textrec();
		redraw_text();
	}
}

//function for mouseup and touch events
function mouseup_function()
{
  isDragging = false;
	isDraggingtemp = false;
	isPathDragging = false;
	isPathDragging_text = false;
	isDragging_text =false;

  if(text_index_flag === true)
  {
		redraw_image();
		redraw();
		redraw_textrec();
		redraw_text();
	}
	if(textinput_selected === true)
	{
		document.getElementById("myText").focus();
		//这里仍然保持textinput_selected为true，等键入文字与canvas中textrec对应后再设置为false
	}
}

canvas.addEventListener("touchstart", function (e) {

    if(e.touches.length===1)
    {
		var touch = e.touches[0];
		e.preventDefault();
		//console.log("touchstart")
    var clickX = touch.pageX - canvas.offsetLeft
    var clickY = touch.pageY - canvas.offsetTop
    x_click_move = clickX
    y_click_move = clickY
    mousedown_function(clickX,clickY)
    }
	}, false);

	canvas.addEventListener("touchend", function (e) {
		e.preventDefault();
		console.log("touchup")
    mouseup_function()
	}, false);

	canvas.addEventListener("touchmove", function (e) {
		clickX_touchmove = e.touches[0].pageX - canvas.offsetLeft;
		clickY_touchmove = e.touches[0].pageY - canvas.offsetTop;
		if(Math.abs(clickX_touchmove - x_click_move)>1||Math.abs(clickY_touchmove - y_click_move)>1)
	{
	  x_click_move = clickX_touchmove;
	  y_click_move = clickY_touchmove;
	  mousemove_function(clickX_touchmove, clickY_touchmove)
  }
		//console.log("touchmove")
	}, false);

// onmousedown event
canvas.onmousedown=function(e){
	var clickX = e.pageX - canvas.offsetLeft;
	var clickY = e.pageY - canvas.offsetTop;
	x_click_move = clickX;
	y_click_move = clickY;
  mousedown_function(clickX,clickY)
 }

// onmousemove event
canvas.onmousemove = function(e) {

	textinput_selected = false;
  clickX_mousemove = e.pageX - canvas.offsetLeft;
	clickY_mousemove = e.pageY - canvas.offsetTop;
	if(Math.abs(clickX_mousemove - x_click_move)>1||Math.abs(clickY_mousemove - y_click_move)>1)
	{
	  x_click_move = clickX_mousemove;
	  y_click_move = clickY_mousemove;
	  mousemove_function(clickX_mousemove, clickY_mousemove)
  }
}

// onmouseup event
canvas.onmouseup = function(){
  mouseup_function()
}

// onmouseout event of canvas
canvas.onmouseout = function(){
  console.log("onmouseout")
	isDragging = false;
	isDraggingtemp = false;
	isPathDragging = false;
	isPathDragging_text = false;
	isDragging_text = false;
	//textinput_selected = false;
}

// Download text file
function download_txt(filename,content,contentType) {
    if (!contentType) contentType = 'text/plain';
    var a = document.createElement('a');
    var blob = new Blob([content], { 'type': contentType });
    a.href = window.URL.createObjectURL(blob);
    a.download = filename;    //filename的后缀要与text/plain相符
    a.click();
}

// getCookie
function getCookie(cname){
    var name = cname + "=";
    var ca = document.cookie.split(';');
    for(var i=0; i<ca.length; i++) {
        var c = ca[i].trim();
        if (c.indexOf(name)===0) { return c.substring(name.length,c.length); }
    }
    return "";
}

// Save the canvas as an image and download
function download_img(filename){
		context.clearRect(0, 0, canvas.width, canvas.height);
		redraw_image();
	  redraw();
		redraw_text();             //不重绘文本框
    canvas.toBlob(function (blobObj) {
    var a_img_downlaod = document.createElement('a');
    a_img_downlaod.href = window.URL.createObjectURL(blobObj);
    a_img_downlaod.download = filename;    //filename的后缀要与text/plain相符
    a_img_downlaod.click();
})
}

// Save the annotation results and download
function save_txt_vertexes_and_text() {
  text_save = "";    //首先初始化
  for (polygon_i1 = 0; polygon_i1 < polygonlist.length; polygon_i1++)
  {

    for (var i = 0; i < polygonlist[polygon_i1].length; i++)
    {
      text_save = text_save + polygonlist[polygon_i1][i].x / canvas_width + ",";
      if(i!==polygonlist[polygon_i1].length-1)
      {
        text_save = text_save + polygonlist[polygon_i1][i].y / canvas_height+ ",";
      }else
      {
        text_save = text_save + polygonlist[polygon_i1][i].y / canvas_height
      }
    }
    text_save = text_save + "\n";

      if(polygon_index_list[polygon_i1].has_textrec === true)
      {
        var textrec_index_temp = polygon_index_list[polygon_i1].textrec_index
        for(var i = 0; i < textinputlist.length; i++)
        {
          if(textinputlist[i].textrec_index === textrec_index_temp)
          {
            text_save = text_save + textinputlist[i].string_textinput + "\n";
          }
        }
      }else
      {
        text_save = text_save + "no text detected" + "\n"
      }
  }
  //console.log(text_save);
  var save_txt_name = txt_download + "_modified.txt";
  var save_image_name = image_download_name + "_modified.jpg";

  download_txt(save_txt_name, text_save);
  download_img(save_image_name);
}

// change the red color channel of selected object
function color_red_change()
{
    color_change_flag = true;
    console.log("chage color red");
    if(colorchange_selected_flag === true)
    {
      if(colorchange_polygon_flag === true){

        var color_red_current=document.getElementById("colorbar_red").value;
        var current_color_polygon = polygon_index_list[polygon_selected].color;
        var color_num = parseInt(color_red_current);
        var color_num_hex = color_num.toString(16);
        if(color_num<16){color_num_hex = "0"+ color_num_hex;}
        var color_temp_polygon = current_color_polygon.substring(3,7);
        var color_change_polygon = "#" + color_num_hex + color_temp_polygon;
        polygon_index_list[polygon_selected].color = color_change_polygon;
        context.clearRect(0, 0, canvas.width, canvas.height);
		    redraw_image();
		    redraw();
		    redraw_textrec();
		    redraw_text();
      }
      if(colorchange_text_flag === true){

        var color_red_current_text=document.getElementById("colorbar_red").value;
        var current_color_text = textrec_index_list[textrec_selected].color;
        var color_num_text = parseInt(color_red_current_text);
        var color_num_hex_text = color_num_text.toString(16);
        if(color_num_text<16){color_num_hex_text = "0"+ color_num_hex_text;}
        var color_temp_text = current_color_text.substring(3,7);
        var color_change_text = "#" + color_num_hex_text + color_temp_text;
        textrec_index_list[textrec_selected].color = color_change_text;
        context.clearRect(0, 0, canvas.width, canvas.height);
		    redraw_image();
		    redraw();
		    redraw_textrec();
		    redraw_text();

      }
    }
    color_change_flag = false;
}


function color_green_change()
{
    color_change_flag = true;
    console.log("chage color green");
    if(colorchange_selected_flag === true)
    {
      if(colorchange_polygon_flag === true){

        var color_green_current=document.getElementById("colorbar_green").value;
        var current_color_polygon = polygon_index_list[polygon_selected].color;
        var color_num = parseInt(color_green_current);
        var color_num_hex = color_num.toString(16);
        if(color_num<16){color_num_hex = "0"+ color_num_hex;}
        var color_temp_polygon_red = current_color_polygon.substring(1,3);
        var color_temp_polygon_blue = current_color_polygon.substring(5,7);
        var color_change_polygon = "#" + color_temp_polygon_red + color_num_hex + color_temp_polygon_blue;
        polygon_index_list[polygon_selected].color = color_change_polygon;
        context.clearRect(0, 0, canvas.width, canvas.height);
		    redraw_image();
		    redraw();
		    redraw_textrec();
		    redraw_text();
      }
      if(colorchange_text_flag === true){

        var color_green_current_text=document.getElementById("colorbar_green").value;
        var current_color_text = textrec_index_list[textrec_selected].color
        var color_num_text = parseInt(color_green_current_text);
        var color_num_hex_text = color_num_text.toString(16);
        if(color_num_text<16){color_num_hex_text = "0"+ color_num_hex_text;}
        var color_temp_text_red = current_color_text.substring(1,3);
        var color_temp_text_blue = current_color_text.substring(5,7);
        var color_change_text = "#" + color_temp_text_red + color_num_hex_text + color_temp_text_blue;
        textrec_index_list[textrec_selected].color = color_change_text;
        context.clearRect(0, 0, canvas.width, canvas.height);
		    redraw_image();
		    redraw();
		    redraw_textrec();
		    redraw_text();
      }
    }
    color_change_flag = false;

}

function color_blue_change()
{
    color_change_flag = true;
    console.log("chage color blue");
    if(colorchange_selected_flag === true)
    {
      if(colorchange_polygon_flag === true){

        var color_blue_current=document.getElementById("colorbar_blue").value;     //获取值，然后转换为Int，并使用toString方法
        var color_num = parseInt(color_blue_current);
        var color_hex = color_num.toString(16);
        if(color_num<16){color_hex = "0"+ color_hex;}
        var current_color_polygon = polygon_index_list[polygon_selected].color;
        var color_temp_polygon = current_color_polygon.substring(1,5);
        var color_change_polygon = "#" + color_temp_polygon + color_hex;
        polygon_index_list[polygon_selected].color = color_change_polygon;
        context.clearRect(0, 0, canvas.width, canvas.height);
		    redraw_image();
		    redraw();
		    redraw_textrec();
		    redraw_text();
      }
      if(colorchange_text_flag === true){

        var color_blue_current_text=document.getElementById("colorbar_blue").value;
        var current_color_text = textrec_index_list[textrec_selected].color;
        var color_num_text = parseInt(color_blue_current_text);
        var color_hex_text = color_num_text.toString(16);
        if(color_num_text<16){color_hex_text = "0"+ color_hex_text;}
        var color_temp_text = current_color_text.substring(1,5);
        var color_change_text = "#" + color_temp_text + color_hex_text;
        textrec_index_list[textrec_selected].color = color_change_text;
        context.clearRect(0, 0, canvas.width, canvas.height);
		    redraw_image();
		    redraw();
		    redraw_textrec();
		    redraw_text();

      }
    }
    color_change_flag = false;
}


function sleep(numberMillis) {
var now = new Date();
var exitTime = now.getTime() + numberMillis;
while (true) {
now = new Date();
if (now.getTime() > exitTime)
return;
}
}

// Use the EAST detection algorithm

function upload_east_detection_path()
{
    var Cookies = document.cookie;
    var cookies_list = Cookies.split(';');
    //console.log("cookies list");
    //console.log(cookies_list);
    var Xcsrftoken_user = getCookie("csrftoken");
    console.log("Xcsrftoken_user: ", Xcsrftoken_user);

    $.ajax({
      type: 'POST',
      url: '/east_upload_filepath/',
      data: JSON.stringify({
            image_filepath: image_path,
            csrf_user: Xcsrftoken_user,
            }),
      aynsc: true,
      beforeSend: function (xhr, settings) {
        xhr.setRequestHeader("X-CSRFToken", '{{ csrf_token }}');
    },
      contentType: 'json',
      success: function(data)
      {
        console.log("posted successfully")
        //sleep(3000)
        console.log(data)
        var data_from_ajax = String(data.file_content)
        var data_split_results = data_from_ajax.split("***")
        var polygon_temp = []
        var textrec_temp = []
        var x_temp
        var y_temp
        for(var i1=0; i1<data_split_results.length;i1++)
        {
          var data_split = data_split_results[i1].split("$$&")
          console.log("data_split: ", data_split)
          for(var i = 0; i < 4; i++)
          {
            x_temp = parseInt(data_split[2*i])
            y_temp = parseInt(data_split[2*i+1])
            x_temp = x_temp * canvas_width / image1.width
            y_temp = y_temp * canvas_height / image1.height
            var vertex_temp = new Vertex(x_temp, y_temp)
            polygon_temp.push(vertex_temp)
            if (i === 0) {
                var vertex_bottomright = new Vertex(x_temp - 5, y_temp - 5)
                textrec_temp.push(vertex_bottomright)
                var vertex_topleft = new Vertex(x_temp - 20 - 10 * 3, y_temp - 20)
                textrec_temp.push(vertex_topleft)
              }
          }
          polygonlist.push(polygon_temp)
          polygon_temp = []
          textreclist.push(textrec_temp)
          textrec_temp = []

          var polygon_index_temp = new Polygon(polygon_temp, "#0033bb", true, textreclist.length - 1)
          polygon_index_list.push(polygon_index_temp)
          var textrec_index_temp = new Textrec(textrec_temp, "#00ff00", true, polygonlist.length - 1)
          textrec_index_list.push(textrec_index_temp)

          var textinput_temp = new Textinput("     ", textreclist.length - 1)
          textinputlist.push(textinput_temp)
        }
        context.clearRect(0, 0, canvas.width, canvas.height);
        redraw_image();
        redraw();
        redraw_textrec();
        redraw_text();
      }
    });
}

// Download tutorial
function download_tutorial_txt()
{
  var tutorial_text_path = "http://127.0.0.1:8000/media/tutorial/tutorial_text.txt"
  $.ajax({
    url: tutorial_text_path,
    dataType: 'text',
    async: true,
    success: function(data) {
      alert(data);
      var tutorial_text = String(data);
      download_txt("tutorial.txt",tutorial_text)
    }
  });
}

function E_keyboard_function()
{
  if((one_key_flag === false)&&
		(isDragging === false)&&(isPathDragging === false)&&(deleteflag === true)&&(textinput_selected === false)
		&&(document.getElementById("myText") !== document.activeElement)&&(vertex_adding_flag === false)&&(color_change_flag === false))
  {
    E_keyboard()
  }
}

function F_keyboard_function()
{
  if((one_key_flag === false)&&
		(polygontemp.length>2)&&(isDragging === false)&&(isPathDragging === false)&&(textinput_selected === false)
		&&(document.getElementById("myText") !== document.activeElement)&&(vertex_adding_flag === false)&&(color_change_flag === false))
	{
		F_keyboard()
	}
}

function A_keyboard_function()
{
  if((one_key_flag === false)&& (isDragging === false)&&(isPathDragging === false)
		&&(document.getElementById("myText") !== document.activeElement)&&(vertex_adding_flag === true)&&(color_change_flag === false))
	{
	  one_key_flag = true;
		vertex_adding_flag = !(vertex_adding_flag);
		one_key_flag = false;
	}
}


function T_keyboard_function()
{
  if((one_key_flag === false)&&(isDragging === false)&&(isPathDragging === false)
		&&(vertex_adding_flag === false)&&(color_change_flag === false))
	{
	  one_key_flag = true;
		textrec_setupflag = !(textrec_setupflag);
		one_key_flag = false;
	}
}


function Enter_keyboard_function()
{
  if((one_key_flag === false)&& (isDragging === false)&&(isPathDragging === false)
    &&(textinput_selected === true)&&(vertex_adding_flag === false)&&(color_change_flag === false))
	  {
	    Enter_keyboard()
	  }
}

function set_href_index()
{
  window.location.href = "http://127.0.0.1:8000"
}

</script>

		<br>
		<p><input type="text" value="" id="myText" />  input text<p>

    <input type="range" min="0" max="255" step="1" value="50" onchange="color_red_change()" id="colorbar_red"  >  R channel
    <input type="range" min="0" max="255" step="1" value="50" onchange="color_green_change()" id="colorbar_green"  >  G channel
    <input type="range" min="0" max="255" step="1" value="50" onchange="color_blue_change()" id="colorbar_blue"  >  B channel

      <p>
        <button2 type="button" id="save" onclick="save_txt_vertexes_and_text()"> save(S) </button2>
        <button2 type="button" id="next_image" onclick="next_image()"> next image(N)</button2>

        <button2 type="button" id="detection" onclick="upload_east_detection_path()"> pre-detect(D)</button2>
        <button2 type="button" id="download tutorial" onclick="download_tutorial_txt()"> tutorial </button2>
        <button2 type="button" id="href index" onclick="set_href_index()"> back </button2>
      <p>

	</body>
</html>
